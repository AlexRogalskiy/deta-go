package deta

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"strings"
)

var (
	// ErrBadProjectKey bad project key
	ErrBadProjectKey = errors.New("bad project key")
	// ErrTooManyItems too many items
	ErrTooManyItems = errors.New("too many items")
	// ErrBadItem bad item
	ErrBadItem = errors.New("bad item")
	// ErrBadDestination bad destination
	ErrBadDestination = errors.New("bad destination")
)

// Base deta base
type Base struct {
	// deta api client
	client *detaClient

	// auth info for authenticating requests
	auth *authInfo

	// Util base utilities
	Util *util
}

// Items always stored as a map of string to interface{}
type baseItem map[string]interface{}

// Query datatype
type Query []map[string]interface{}

// Updates datatype
type Updates map[string]interface{}

// NewBase returns a pointer to a new Base
func newBase(projectKey, baseName, rootEndpoint string) (*Base, error) {
	// verify project id
	parts := strings.Split(projectKey, "_")
	if len(parts) != 2 {
		return nil, ErrBadProjectKey
	}
	projectID := parts[0]

	// root endpoint for the base
	rootEndpoint = fmt.Sprintf("%s/%s/%s", rootEndpoint, projectID, baseName)

	return &Base{
		client: newDetaClient(rootEndpoint, &authInfo{
			authType:    "api-key",
			headerKey:   "X-API-Key",
			headerValue: projectKey,
		}),
	}, nil
}

// modifies item to a baseItem
func (b *Base) modifyItem(item interface{}) (baseItem, error) {
	data, err := json.Marshal(item)
	if err != nil {
		return nil, ErrBadItem
	}
	var bi baseItem
	err = json.Unmarshal(data, &bi)
	if err != nil {
		return nil, fmt.Errorf("%w: %s", ErrBadItem, err)
	}
	return bi, nil
}

type putResponse struct {
	Processed map[string][]baseItem `json:"processed"`
	Failed    map[string][]baseItem `json:"failed"`
}

func (b *Base) put(items []interface{}) ([]string, error) {

	var modifiedItems []baseItem
	for _, item := range items {
		bi, err := b.modifyItem(item)
		if err != nil {
			return nil, err
		}
		modifiedItems = append(modifiedItems, bi)
	}

	body := map[string]interface{}{
		"items": modifiedItems,
	}
	o, err := b.client.request(&requestInput{
		Path:   "/items",
		Method: "PUT",
		Body:   body,
	})
	if err != nil {
		return nil, err
	}

	var pr putResponse
	err = json.Unmarshal(o.Body, &pr)
	if err != nil {
		return nil, err
	}

	var keys []string
	for _, item := range pr.Processed["items"] {
		keys = append(keys, item["key"].(string))
	}

	return keys, nil
}

// Put operation for Deta Base
// Put puts a new item in the database under the provided key
// If item with the same key already exists in the database, the existing item is overwritten
// If the 'key' is empty a key is autogenerated
func (b *Base) Put(item interface{}) (string, error) {
	if item == nil {
		return "", nil
	}

	items := []interface{}{item}
	putKeys, err := b.put(items)
	if err != nil {
		return "", err
	}
	return putKeys[0], nil
}

// PutMany operation for Deta Base
// Puts at most 25 items at a time
func (b *Base) PutMany(items []interface{}) ([]string, error) {
	if len(items) == 0 {
		return nil, nil
	}
	if len(items) > 25 {
		return nil, ErrTooManyItems
	}
	return b.put(items)
}

// Get gets an item with 'key' from the database
// the item is scanned onto `dest`
func (b *Base) Get(key string, dest interface{}) error {
	escapedKey := url.PathEscape(key)
	o, err := b.client.request(&requestInput{
		Path:   fmt.Sprintf("/items/%s", escapedKey),
		Method: "GET",
	})
	if err != nil {
		return err
	}
	err = json.Unmarshal(o.Body, &dest)
	if err != nil {
		return fmt.Errorf("%w: %v", ErrBadDestination, err)
	}
	return nil
}

// Insert inserts an item in the database only if the key does not exist
func (b *Base) Insert(item interface{}) (string, error) {
	modifiedItem, err := b.modifyItem(item)
	if err != nil {
		return "", err
	}

	o, err := b.client.request(&requestInput{
		Path:   "/items",
		Method: "POST",
		Body:   modifiedItem,
	})

	if err != nil {
		return "", err
	}

	var bi baseItem
	err = json.Unmarshal(o.Body, &bi)
	if err != nil {
		return "", err
	}
	return bi["key"].(string), nil
}

type updateRequest struct {
	Set       map[string]interface{}   `json:"set"`
	Trim      []string                 `json:"trim"`
	Append    map[string][]interface{} `json:"append"`
	Prepend   map[string][]interface{} `json:"prepend"`
	Increment map[string]interface{}   `json:"increment"`
}

// converts updates to an update request
func (b *Base) updatesToUpdateRequest(updates Updates) *updateRequest {
	var updateReq updateRequest
	for k, v := range updates {
		switch v.(type) {
		case trimUtil:
			updateReq.Trim = append(updateReq.Trim, k)
		case appendUtil:
			updateReq.Append[k] = v.(appendUtil).value
		case prependUtil:
			updateReq.Prepend[k] = v.(prependUtil).value
		case incrementUtil:
			updateReq.Increment[k] = v.(incrementUtil).value
		default:
			updateReq.Set[k] = v
		}
	}
	return &updateReq
}

// Update updates the item with the 'key' with the provide 'updates'
func (b *Base) Update(updates Updates, key string) error {
	// escape key
	escapedKey := url.PathEscape(key)

	ur := b.updatesToUpdateRequest(updates)
	_, err := b.client.request(&requestInput{
		Path:   fmt.Sprintf("/%s", escapedKey),
		Method: "PATCH",
		Body:   ur,
	})
	if err != nil {
		return err
	}
	return nil
}

// Delete deletes an item from the database
func (b *Base) Delete(key string) error {
	// escape the key
	escapedKey := url.PathEscape(key)

	_, err := b.client.request(&requestInput{
		Path:   fmt.Sprintf("/%s", escapedKey),
		Method: "DELETE",
	})
	if err != nil {
		return err
	}
	return nil
}

type paging struct {
	Size int     `json:"size"`
	Last *string `json:"last"`
}

type fetchRequest struct {
	Query Query   `json:"query"`
	Last  *string `json:"last,omitempty"`
	Limit *int    `json:"limite,omitempty"`
}

type fetchResponse struct {
	Paging *paging       `json:"paging"`
	Items  []interface{} `json:"items"`
}

func (b *Base) fetch(req *fetchRequest) (*fetchResponse, error) {
	o, err := b.client.request(&requestInput{
		Path:   fmt.Sprintf("/query"),
		Method: "POST",
		Body:   req,
	})
	if err != nil {
		return nil, err
	}
	var fr fetchResponse
	err = json.Unmarshal(o.Body, &fr)
	if err != nil {
		return nil, err
	}
	return &fr, nil
}

// Fetch fetches maximum 'limit' items from the database based on the 'query'
// Provide a 'limit' value of 0 or less to apply no limits
// It scans the result onto 'dest'
// A nil query fetches all items from the database
// Fetch is paginated, returns the last key fetched if further pages are left
func (b *Base) Fetch(query Query, dest interface{}, limit int) (string, error) {
	req := &fetchRequest{
		Query: query,
	}
	if limit > 0 {
		req.Limit = &limit
	}

	res, err := b.fetch(req)
	if err != nil {
		return "", err
	}

	data, err := json.Marshal(res.Items)
	if err != nil {
		return "", err
	}
	err = json.Unmarshal(data, &dest)
	if err != nil {
		return "", fmt.Errorf("%w: %v", ErrBadDestination, err)
	}

	lastKey := ""
	if res.Paging.Last != nil {
		lastKey = *res.Paging.Last
	}
	return lastKey, nil
}

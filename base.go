package deta

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/url"
	"reflect"
	"strings"
)

var (
	// ErrBadProjectKey bad project key
	ErrBadProjectKey = errors.New("bad project key")
	// ErrTooManyItems too many items
	ErrTooManyItems = errors.New("too many items")
)

// Base deta base
type Base struct {
	// deta api client
	client *detaClient

	// auth info for authenticating requests
	auth *authInfo

	// Util base utilities
	Util *util
}

// Query datatype
type Query []map[string]interface{}

// Updates datatype
type Updates map[string]interface{}

// NewBase returns a pointer to a new Base
func newBase(projectKey, baseName, rootEndpoint string) (*Base, error) {
	// verify project id
	parts := strings.Split(projectKey, "_")
	if len(parts) != 2 {
		return nil, ErrBadProjectKey
	}
	projectID := parts[0]

	// root endpoint for the base
	rootEndpoint = fmt.Sprintf("%s/%s/%s", rootEndpoint, projectID, baseName)

	return &Base{
		client: newDetaClient(rootEndpoint, &authInfo{
			authType:    "api-key",
			headerKey:   "X-Deta-API-Key",
			headerValue: projectKey,
		}),
	}, nil
}

// checks if item is a struct or a map
// if not adds the item as a 'value' field
func (b *Base) modifyItem(item interface{}) interface{} {
	// check item type
	switch reflect.ValueOf(item).Kind() {
	// if struct return item as is
	case reflect.Struct:
		return item
	// if pointer check type of value ptr is pointing to
	case reflect.Ptr:
		switch reflect.Indirect(reflect.ValueOf(item)).Elem().Kind() {
		case reflect.Struct:
			return item
		case reflect.Map:
			return item
		default:
			return map[string]interface{}{
				"value": item,
			}
		}
	// if map return as is
	case reflect.Map:
		return item
	// other cases (ints, bools, strings etc)
	// put the item under field value
	default:
		return map[string]interface{}{
			"value": item,
		}
	}
}

type baseItem map[string]interface{}

type putResponse struct {
	Processed map[string][]baseItem `json:"processed"`
	Failed    map[string][]baseItem `json:"failed"`
}

func (b *Base) put(items []interface{}) ([]string, error) {

	var modifiedItems []interface{}
	for _, item := range items {
		modifiedItems = append(modifiedItems, b.modifyItem(item))
	}

	body := map[string]interface{}{
		"items": modifiedItems,
	}
	o, err := b.client.request(&requestInput{
		Path:   "/items",
		Method: "PUT",
		Body:   body,
	})
	if err != nil {
		return nil, err
	}

	var pr putResponse
	err = json.Unmarshal(o.Body, &pr)
	if err != nil {
		return nil, err
	}

	var keys []string
	for _, item := range pr.Processed["items"] {
		keys = append(keys, item["key"].(string))
	}

	return keys, nil
}

// Put operation for Deta Base
// Put puts a new item in the database under the provided key
// If item with the same key already exists in the database, the existing item is overwritten
// If the 'key' is empty a key is autogenerated
func (b *Base) Put(item interface{}) (string, error) {
	if item == nil {
		return "", nil
	}

	items := []interface{}{item}
	putKeys, err := b.put(items)
	if err != nil {
		return "", err
	}
	return putKeys[0], nil
}

// PutMany operation for Deta Base
// Puts at most 25 items at a time
func (b *Base) PutMany(items []interface{}) ([]string, error) {
	if len(items) == 0 {
		return nil, nil
	}
	if len(items) > 25 {
		return nil, ErrTooManyItems
	}
	return b.put(items)
}

// Get gets an item with 'key' from the database
// the item is scanned onto `dest`
func (b *Base) Get(key string, dest interface{}) error {
	escapedKey := url.PathEscape(key)
	o, err := b.client.request(&requestInput{
		Path:   fmt.Sprintf("/items/%s", escapedKey),
		Method: "GET",
	})
	if err != nil {
		return err
	}
	err = json.Unmarshal(o.Body, &dest)
	if err != nil {
		return err
	}
	return nil
}

// Insert inserts an item in the database only if the key does not exist
func (b *Base) Insert(item interface{}) (string, error) {
	o, err := b.client.request(&requestInput{
		Path:   "/items",
		Method: "POST",
		Body:   b.modifyItem(item),
	})

	if err != nil {
		return "", err
	}

	var bi baseItem
	err = json.Unmarshal(o.Body, &bi)
	if err != nil {
		return "", err
	}
	return bi["key"].(string), nil
}

type updateRequest struct {
	Set       map[string]interface{}   `json:"set"`
	Trim      []string                 `json:"trim"`
	Append    map[string][]interface{} `json:"append"`
	Prepend   map[string][]interface{} `json:"prepend"`
	Increment map[string]interface{}   `json:"increment"`
}

// converts updates to an update request
func (b *Base) updatesToUpdateRequest(updates Updates) *updateRequest {
	var updateReq updateRequest
	for k, v := range updates {
		switch v.(type) {
		case trimUtil:
			updateReq.Trim = append(updateReq.Trim, k)
		case appendUtil:
			updateReq.Append[k] = v.(appendUtil).value
		case prependUtil:
			updateReq.Prepend[k] = v.(prependUtil).value
		case incrementUtil:
			updateReq.Increment[k] = v.(incrementUtil).value
		default:
			updateReq.Set[k] = v
		}
	}
	return &updateReq
}

// Update updates the item with the 'key' with the provide 'updates'
func (b *Base) Update(updates Updates, key string) error {
	// escape key
	escapedKey := url.PathEscape(key)

	ur := b.updatesToUpdateRequest(updates)
	_, err := b.client.request(&requestInput{
		Path:   fmt.Sprintf("/%s", escapedKey),
		Method: "PATCH",
		Body:   ur,
	})
	if err != nil {
		return err
	}
	return nil
}

// Delete deletes an item from the database
func (b *Base) Delete(key string) error {
	// escape the key
	escapedKey := url.PathEscape(key)

	_, err := b.client.request(&requestInput{
		Path:   fmt.Sprintf("/%s", escapedKey),
		Method: "DELETE",
	})
	if err != nil {
		return err
	}
	return nil
}

type paging struct {
	Size int     `json:"size"`
	Last *string `json:"last"`
}

type fetchRequest struct {
	Query Query   `json:"query"`
	Last  *string `json:"last,omitempty"`
	Limit *int    `json:"limite,omitempty"`
}

type fetchResponse struct {
	Paging *paging       `json:"paging"`
	Items  []interface{} `json:"items"`
}

func (b *Base) fetch(req *fetchRequest) (*fetchResponse, error) {
	o, err := b.client.request(&requestInput{
		Path:   fmt.Sprintf("/query"),
		Method: "POST",
		Body:   req,
	})
	if err != nil {
		return nil, err
	}
	var fr fetchResponse
	err = json.Unmarshal(o.Body, &fr)
	if err != nil {
		return nil, err
	}
	return &fr, nil
}

// Fetch fetches maximum 'limit' items from the database based on the 'query'
// Provide a 0 limit to fetch everything from the database
// Fetch is paginated, can submit multiple requests
// It scans the items onto 'dest'
// A nil query fetches all items from the database
func (b *Base) Fetch(query Query, limit int, dest interface{}) error {
	req := &fetchRequest{
		Query: query,
	}
	if limit != 0 {
		req.Limit = &limit
	}

	firstIteration := true

	res, err := b.fetch(req)
	if err != nil {
		return err
	}

	var totalItems []baseItem
	for res.Paging.Last != nil || firstIteration {
		firstIteration = false

		req.Last = res.Paging.Last
		res, err := b.fetch(req)
		if err != nil {
			return err
		}

		data, err := json.Marshal(res.Items)
		if err != nil {
			return err
		}

		var items []baseItem
		err = json.Unmarshal(data, &items)
		if err != nil {
			return err
		}
		totalItems = append(totalItems, items...)
	}

	if len(totalItems) > limit {
		totalItems = totalItems[:limit]
	}

	data, err := json.Marshal(totalItems)
	if err != nil {
		return err
	}
	return json.Unmarshal(data, &dest)
}
